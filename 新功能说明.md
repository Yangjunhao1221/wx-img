# 新功能说明

## 功能1: 更换布局时保留图片 ✅

### 功能描述
更换布局时不再删除已上传的图片，而是智能地将图片迁移到新布局中。

### 实现逻辑

#### 1. 图片数量 ≤ 新布局槽位数
**示例**: 已有5张图片，选择6张图片的布局
- **结果**: 前5张图片自动填充到新布局的前5个槽位
- **剩余**: 第6个槽位为空，可继续添加图片

#### 2. 图片数量 > 新布局槽位数
**示例**: 已有5张图片，选择4张图片的布局
- **结果**: 前4张图片自动填充到新布局的4个槽位
- **丢弃**: 第5张图片被丢弃（因为新布局只支持4张）

#### 3. 图片数量 < 新布局槽位数
**示例**: 已有2张图片，选择5张图片的布局
- **结果**: 前2张图片自动填充到新布局的前2个槽位
- **剩余**: 后3个槽位为空，可继续添加图片

### 用户体验改进
- ✅ **无需重新上传**: 更换布局时不会丢失已上传的图片
- ✅ **智能迁移**: 图片按顺序自动填充到新布局
- ✅ **即时预览**: 切换布局后立即显示迁移后的效果
- ✅ **无确认弹窗**: 移除了"更换布局将清空图片"的确认弹窗，操作更流畅

### 代码修改

#### `pages/collage/collage.js`

**1. 简化 `changeLayout()` 方法** (Line 2091-2098)
```javascript
// 更换布局 - 保留已有图片
changeLayout () {
  // 直接返回布局选择页面,不清空图片
  this.setData({
    workflowStep: 'selectLayout'
  });
  console.log('返回布局选择页面,保留已有图片');
}
```

**2. 修改 `onLayoutSelect()` 方法** (Line 2105-2200)
```javascript
// 获取当前已有的图片
const existingImages = [];
if (this.data.imageSlots && this.data.imageSlots.length > 0) {
  this.data.imageSlots.forEach(slot => {
    if (!slot.isEmpty && slot.image) {
      existingImages.push(slot.image);
    }
  });
}

// 初始化新布局的图片槽位,并迁移已有图片
const imageSlots = [];
const selectedImages = [];

for (let i = 0; i < template.imageCount; i++) {
  if (i < existingImages.length) {
    // 迁移已有图片到新布局
    imageSlots.push({
      index: i,
      image: existingImages[i],
      isEmpty: false
    });
    selectedImages.push(existingImages[i]);
  } else {
    // 空槽位
    imageSlots.push({
      index: i,
      image: null,
      isEmpty: true
    });
  }
}
```

**3. 智能绘制** (Line 2182-2191)
```javascript
// 检查是否有图片需要绘制
if (selectedImages.length > 0) {
  // 有图片,直接更新Canvas
  that.updateCanvas();
} else {
  // 无图片,绘制占位框
  that.drawPlaceholders();
}
```

---

## 功能2: 图片显示模式切换 ✅

### 功能描述
提供两种图片显示模式，用户可以通过开关自由切换。

### 显示模式

#### 1. **填满模式 (Cover)** - 默认
- **特点**: 图片填满整个槽位，可能会裁剪部分内容
- **适用**: 追求整齐美观，不介意裁剪
- **效果**: 无留白，视觉效果更统一

**算法逻辑**:
```javascript
if (imgRatio > containerRatio) {
  // 图片比容器宽,以容器高度为准
  drawHeight = height;
  drawWidth = height * imgRatio;
  drawX = x + (width - drawWidth) / 2;  // 居中裁剪
  drawY = y;
} else {
  // 图片比容器窄,以容器宽度为准
  drawWidth = width;
  drawHeight = width / imgRatio;
  drawX = x;
  drawY = y + (height - drawHeight) / 2;  // 居中裁剪
}
```

#### 2. **完全显示模式 (Contain)**
- **特点**: 完整显示图片，可能会有留白
- **适用**: 不想裁剪图片内容
- **效果**: 可能有留白，但图片完整

**算法逻辑**:
```javascript
if (imgRatio > containerRatio) {
  // 图片比容器宽,以容器宽度为准
  drawWidth = width;
  drawHeight = width / imgRatio;
  drawX = x;
  drawY = y + (height - drawHeight) / 2;  // 居中显示
} else {
  // 图片比容器窄,以容器高度为准
  drawHeight = height;
  drawWidth = height * imgRatio;
  drawX = x + (width - drawWidth) / 2;  // 居中显示
  drawY = y;
}
```

### 用户界面

**位置**: 样式控制区域的第一项

**显示**:
```
图片显示    [填满]  ⚪━━━━
```
或
```
图片显示    [完全显示]  ━━━━⚪
```

**交互**:
- 点击开关切换模式
- 切换后立即重绘Canvas
- 显示Toast提示: "图片显示: 填满" 或 "图片显示: 完全显示"

### 代码修改

#### `pages/collage/collage.js`

**1. 添加数据字段** (Line 52)
```javascript
data: {
  // ...
  imageFitMode: 'cover', // 'cover' 填满槽位, 'contain' 完全显示
}
```

**2. 添加切换方法** (Line 2100-2119)
```javascript
// 切换图片显示模式
toggleImageFitMode () {
  const newMode = this.data.imageFitMode === 'cover' ? 'contain' : 'cover';
  const modeName = newMode === 'cover' ? '填满' : '完全显示';
  
  this.setData({
    imageFitMode: newMode
  }, () => {
    // 重新绘制Canvas
    this.updateCanvas();
    
    wx.showToast({
      title: `图片显示: ${modeName}`,
      icon: 'success',
      duration: 1500
    });
  });
  
  console.log('切换图片显示模式:', newMode);
}
```

**3. 修改图片绘制逻辑** (Line 934-996)
```javascript
// 计算图片在容器中的显示尺寸和位置
const imgRatio = img.width / img.height;
const containerRatio = width / height;
const fitMode = that.data.imageFitMode; // 'cover' 或 'contain'

let drawWidth, drawHeight, drawX, drawY;

if (fitMode === 'cover') {
  // cover模式: 填满容器,可能裁剪图片
  // ...
} else {
  // contain模式: 完全显示图片,可能有留白
  // ...
}
```

#### `pages/collage/collage.wxml`

**添加开关控件** (Line 123-128)
```xml
<!-- 图片显示模式 -->
<view class="control-item">
  <text class="control-label">图片显示</text>
  <view class="control-switch-wrapper">
    <text class="switch-label">{{imageFitMode === 'cover' ? '填满' : '完全显示'}}</text>
    <switch checked="{{imageFitMode === 'cover'}}" bindchange="toggleImageFitMode" color="#007AFF"/>
  </view>
</view>
```

#### `pages/collage/collage.wxss`

**添加样式** (Line 654-665)
```css
.control-switch-wrapper {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.switch-label {
  font-size: 14px;
  color: #666;
}
```

---

## 测试步骤

### 测试功能1: 布局切换保留图片

1. **选择一个布局** (例如: "2×2网格 4张")
2. **上传3张图片**
3. **点击"更换布局"**
4. **选择另一个布局** (例如: "横向三列 3张")
5. **验证**: 之前的3张图片应该自动填充到新布局中
6. **再次更换布局** (例如: "横向两列 2张")
7. **验证**: 前2张图片应该保留，第3张被丢弃

### 测试功能2: 图片显示模式

1. **选择布局并上传图片**
2. **观察默认效果** (应该是"填满"模式)
3. **点击"图片显示"开关**
4. **验证**: 
   - 开关切换到"完全显示"
   - Canvas立即重绘
   - 显示Toast: "图片显示: 完全显示"
   - 图片完整显示，可能有留白
5. **再次点击开关**
6. **验证**:
   - 开关切换回"填满"
   - Canvas立即重绘
   - 显示Toast: "图片显示: 填满"
   - 图片填满槽位，可能被裁剪

---

## 注意事项

### 功能1
- ⚠️ 如果新布局槽位数少于已有图片数，多余的图片会被丢弃
- ✅ 图片迁移按顺序进行，保持原有顺序
- ✅ 迁移后立即显示效果，无需手动刷新

### 功能2
- ⚠️ 切换模式会立即重绘所有图片，可能有短暂延迟
- ✅ 模式切换是全局的，影响所有槽位的图片
- ✅ 默认模式是"填满"，更符合拼图美观需求

---

## 总结

这两个功能极大地提升了用户体验：

1. **布局切换保留图片**: 让用户可以自由尝试不同布局，无需担心图片丢失
2. **图片显示模式**: 给用户更多控制权，可以根据需求选择裁剪或完整显示

两个功能都不影响现有功能，完全向后兼容！ 🎉

