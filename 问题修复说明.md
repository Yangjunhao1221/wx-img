# 问题修复说明

## 📋 修复的问题

### 问题1: 工具条位置和层级显示问题
**现象**: 工具条的位置显示不正确，层级可能被其他元素遮挡

**原因分析**:
- `global-canvas-wrapper` 没有设置 `position: relative`，导致工具条的 `absolute` 定位参考点不正确
- 工具条的 `z-index` 值不够高，可能被其他元素遮挡
- `overflow: hidden` 导致工具条被裁剪

**解决方案**:
1. 为 `.global-canvas-wrapper` 添加 `position: relative`，作为工具条的定位参考
2. 将 `.global-canvas-wrapper` 的 `overflow` 改为 `visible`，让工具条可以显示在外面
3. 提高工具条的 `z-index` 从 1000 到 9999，确保在最上层
4. 添加 `pointer-events: auto` 确保工具条可以点击

### 问题2: 图片旋转和缩放超出容器
**现象**: 图片旋转或放大后会超出容器边界，显示在其他图片区域

**原因分析**:
- Canvas 变换（旋转、缩放）是在裁剪路径之后应用的
- 变换会改变图片的实际绘制区域，导致超出原始容器边界
- 裁剪路径应该在变换之前设置，这样变换后的图片才会被正确裁剪

**解决方案**:
1. 调整 `loadAndDrawImage` 方法中的绘制顺序：
   - 先设置裁剪路径（`clip()`）
   - 再应用变换（`rotate()`, `scale()`）
   - 最后绘制图片
2. 同样修改导出图片时的绘制逻辑，确保导出效果一致
3. 为 Canvas 元素添加 `overflow: hidden` 和 `border-radius`，双重保险

## 🔧 修改的文件

### 1. pages/collage/collage.wxss

#### 修改1: global-canvas-wrapper 样式
```css
/* 修改前 */
.global-canvas-wrapper {
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  overflow: hidden;
}

/* 修改后 */
.global-canvas-wrapper {
  position: relative; /* 添加相对定位，作为工具条的定位参考 */
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  overflow: visible; /* 改为visible，让工具条可以显示在外面 */
}
```

#### 修改2: Canvas 样式
```css
/* 修改前 */
.global-canvas-wrapper .canvas {
  display: block;
}

/* 修改后 */
.global-canvas-wrapper .canvas {
  display: block;
  border-radius: 8px; /* 添加圆角 */
  overflow: hidden; /* Canvas本身裁剪内容 */
}
```

#### 修改3: 工具条样式
```css
/* 修改前 */
.image-toolbar {
  position: absolute;
  transform: translate(-50%, 0);
  z-index: 1000;
  animation: toolbarFadeIn 0.2s ease-out;
}

/* 修改后 */
.image-toolbar {
  position: absolute;
  transform: translate(-50%, 0);
  z-index: 9999; /* 提高层级，确保在最上层 */
  animation: toolbarFadeIn 0.2s ease-out;
  pointer-events: auto; /* 确保可以点击 */
}
```

### 2. pages/collage/collage.js

#### 修改1: loadAndDrawImage 方法（预览绘制）
**关键改动**: 调整裁剪和变换的顺序

```javascript
// 修改前的顺序
ctx.save();
// 1. 应用变换
ctx.translate(centerX, centerY);
ctx.rotate(rotation * Math.PI / 180);
ctx.scale(scale, scale);
ctx.translate(-centerX, -centerY);
// 2. 设置裁剪
that.roundRect(ctx, x, y, width, height, cornerRadius);
ctx.clip();
// 3. 绘制图片
ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
ctx.restore();

// 修改后的顺序
ctx.save();
// 1. 先设置裁剪（在变换之前）
that.roundRect(ctx, x, y, width, height, cornerRadius);
ctx.clip();
// 2. 再应用变换（在裁剪之后）
ctx.translate(centerX, centerY);
ctx.rotate(rotation * Math.PI / 180);
ctx.scale(scale, scale);
ctx.translate(-centerX, -centerY);
// 3. 绘制图片
ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
ctx.restore();
```

**位置**: 第 1087-1169 行

#### 修改2: 导出图片绘制逻辑
**关键改动**: 同样调整裁剪和变换的顺序

```javascript
// 修改前的顺序
ctx.save();
// 1. 应用变换
ctx.translate(centerX, centerY);
ctx.rotate(rotation * Math.PI / 180);
ctx.scale(scale, scale);
ctx.translate(-centerX, -centerY);
// 2. 设置裁剪
if (that.data.cornerRadius > 0) {
  that.roundRect(ctx, pos.x, pos.y, pos.width, pos.height, radius);
  ctx.clip();
}
// 3. 绘制图片
ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
ctx.restore();

// 修改后的顺序
ctx.save();
// 1. 先设置裁剪（在变换之前）
if (that.data.cornerRadius > 0) {
  that.roundRect(ctx, pos.x, pos.y, pos.width, pos.height, radius);
  ctx.clip();
}
// 2. 再应用变换（在裁剪之后）
ctx.translate(centerX, centerY);
ctx.rotate(rotation * Math.PI / 180);
ctx.scale(scale, scale);
ctx.translate(-centerX, -centerY);
// 3. 绘制图片
ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
ctx.restore();
```

**位置**: 第 1480-1537 行

## 🎯 修复原理

### Canvas 裁剪和变换的工作原理

#### 错误的顺序（修改前）
```
1. 应用变换 → 坐标系改变
2. 设置裁剪 → 裁剪区域也被变换了
3. 绘制图片 → 图片在变换后的坐标系中绘制
结果：裁剪区域跟着旋转/缩放，无法限制图片
```

#### 正确的顺序（修改后）
```
1. 设置裁剪 → 在原始坐标系中定义裁剪区域
2. 应用变换 → 只影响后续绘制，不影响裁剪区域
3. 绘制图片 → 图片被变换，但被裁剪区域限制
结果：裁剪区域固定，图片变换后超出部分被裁剪
```

### 示意图

```
原始容器（100x100）
┌─────────────┐
│             │
│   [图片]    │  ← 正常显示
│             │
└─────────────┘

旋转45度（错误顺序）
    ╱╲
   ╱  ╲
  ╱    ╲        ← 超出容器边界
 ╱ [图] ╲
╱        ╲

旋转45度（正确顺序）
┌─────────────┐
│   ╱╲        │
│  ╱  ╲       │  ← 超出部分被裁剪
│ ╱ [图       │
│╱            │
└─────────────┘
```

## ✅ 验证方法

### 测试1: 工具条显示
1. 进入布局拼图页面
2. 添加图片
3. 点击图片
4. **预期**: 工具条正确显示在图片下方（或上方），不被遮挡

### 测试2: 图片旋转不超出
1. 点击图片显示工具条
2. 点击"旋转"按钮多次
3. **预期**: 图片旋转后不会超出容器边界，超出部分被裁剪

### 测试3: 图片放大不超出
1. 点击图片显示工具条
2. 点击"放大"按钮多次
3. **预期**: 图片放大后不会超出容器边界，超出部分被裁剪

### 测试4: 组合变换不超出
1. 点击图片显示工具条
2. 先旋转90度
3. 再放大150%
4. **预期**: 图片始终在容器内，不会影响其他图片

### 测试5: 导出效果一致
1. 对图片进行旋转和缩放
2. 导出图片
3. **预期**: 导出的图片效果与预览完全一致，没有超出容器

## 📊 技术要点

### 1. Canvas 状态管理
- 使用 `ctx.save()` 保存状态
- 使用 `ctx.restore()` 恢复状态
- 确保变换不会影响其他绘制

### 2. 裁剪路径
- `ctx.clip()` 设置裁剪区域
- 裁剪路径在当前坐标系中定义
- 后续绘制都会被裁剪路径限制

### 3. 坐标变换
- `ctx.translate()` 移动坐标原点
- `ctx.rotate()` 旋转坐标系
- `ctx.scale()` 缩放坐标系
- 变换是累积的，需要注意顺序

### 4. 定位参考
- `position: relative` 创建定位上下文
- `position: absolute` 相对于最近的定位祖先
- `z-index` 控制层叠顺序

## 🔍 注意事项

1. **裁剪顺序很重要**
   - 必须在变换之前设置裁剪路径
   - 否则裁剪区域也会被变换

2. **状态管理**
   - 每次绘制前 `save()`
   - 绘制后 `restore()`
   - 避免状态污染

3. **导出一致性**
   - 预览和导出使用相同的绘制逻辑
   - 确保所见即所得

4. **CSS overflow**
   - wrapper 用 `visible` 让工具条显示
   - canvas 用 `hidden` 裁剪内容
   - 双重保险

## 📝 总结

通过调整 Canvas 绘制顺序和 CSS 样式，成功解决了：
1. ✅ 工具条位置和层级显示问题
2. ✅ 图片旋转缩放超出容器问题

关键点：
- **先裁剪，后变换** - 确保图片不超出容器
- **相对定位** - 确保工具条正确定位
- **高层级** - 确保工具条不被遮挡

---

**修复日期**: 2025-11-05  
**修复版本**: v1.0.1  
**状态**: ✅ 已完成

